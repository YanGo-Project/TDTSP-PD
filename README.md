# DemoProject

## 1. Библиотека (де)сереализации JSON формата 
В проекте используется поплуряное решение 'nlohmann': https://github.com/nlohmann/json

Для его установки надо  выполнить команду:
1. ```sudo apt install nlohmann-json3-dev``` на Linux
2. ```brew install nlohmann-json``` на MacOs

## 2. Сборка проекта 

Далее нужно выполнить следующие шаги:
1. ```mkdir build && cd build```
2. ```cmake -DCMAKE_BUILD_TYPE=Debug .. && cmake --build .```

Если все прошло успешно - в папке `build/` появится исполняемый файл **app**.

Для сборки в `Debug` моде вместо пункта 2 выполнить команду ```cmake -DCMAKE_BUILD_TYPE=Debug .. && cmake --build .```.

В данном формате:
1. В консоль будут выводиться промжеточные стадии улучшения маршрутов.
2. Будет происходить валидация маршрута после операции перестройки `crossover` (см. `include/crossover.hpp`).

## 3. Аргументы программы 
Необходимо выполнить следующее: 
```./app -p <problem> -s <solution> -t <time>```
Где:
1. @problem - файл с разрешением `.json`, в котором данные параметры системы.
2. @solution - файл с разерешние `.json`, в который после работы алгоритма будет записано решение.
3. @time - время работы второй части алгоритма в секундах.

Пример:
```./app -p ../data/vrp_problems/1.json -s ../tests/vrp_temp/1.json -t 10```

## 4. Алгоритм работы 

Алгоритм делится на две логические части.

### Первая часть работы алгоритма 

Первая часть алгоритма полностью реализована в файле `src/first_step.cpp` и `include/first_step.hpp`.

Общая идея - пытаемся из всего множества вершин с помошью динамического программирования построить маршурт, 
который бы проходил входные ограничение по времени, расстоянию, минимальному и максимальному числу вершин в нем. 

### Вторая часть алгоритма 

На базе набора вершин из первого шага мы пытаемся перестроить маршурт, чтобы максимизировать целевую функцию 
и все еще вписываться во входные ограничения (время и расстояние пути).
Все идеи описаны в статье, которая лежит в `data/ban2021.pdf`. 
Файлы в `include/` являются различным частями алгоритма из статьи, которые затем собираются в метаэврестический алгоритм в файле `src/algorithm.cpp`.

#### Гиперпараметры второй части алгоритма 

Соответсвтующая им структура `MetaParameters` описана в `include/algorithm.hpp` и инициализируется в `main.cpp:40-49`.

Краткое описание: 
1. `population_size` - размер популяции, с которой мы работаем.
2. `alpha` - используется в генерации пути для популяции, отвечает за количество ближайших соседей к текущей последней вершине, среди которых случайно выбирается следующая. (см. `src/init_population.cpp:101-103`)
3. `beta` - отвечает за распределение случайных и grasp путей в популяции, должен быть в [0, 1.0], если случайная величина принимает значение меньше, то генерируется случаный путь, иначе генерируется grasp путь.
4. `nloop` - количество итераций перестройки маршрута и его улучшения в VNS (см. `src/vns.cpp:10-26`).
5. `kMax` - максимальное количество локальный улучшений, применяемых в VND (см. `src/vnd.cpp:249`).
6. `p` - допустимое ухудшение пути при его перестройке с `DoubleBridge` для выхода из локального минимума (cм. `src/vnd.cpp:288`).
7. `max_iter_without_solution` - максимальное число итерация основного цикла работы алгоритма для популяции, если лучшее решение не меняется. Служит критерием останова работы (см. `src/algorithm.cpp:38`).
8. `max_crossover_candidates` - максимальное число случайных путей из популяции для выбора двух лучших из них для построения нового маршурта (см. `src/algorithm.cpp:35`)

В ходе тестов выяснилось, что порой на некоторых данных не получается сгенерировать популяцию нужного нам размера и мы уходим почти в бесконечный цикл из-за ограничений на время и дистанцию маршрута во входных данных. По этой причине ввелось дополнтиельное ограничение на количество попыток сгенерировать маршрут и работать с тем, что есть, чтобы не тратить процессорное время просто так (см. `max_iterations` в `src/init_population.cpp:15`).